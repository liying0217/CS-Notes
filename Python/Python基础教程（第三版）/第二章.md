# 第二章 列表和元组
1 数据结构式以某种方式（如通过编号）组合起来的数据元素（如数、字符乃至其他数据结构）集合。最基本的数据结构是序列。列表、字符串和数组都属于序列，其中列表是可变的，而元组和字符串是不可变的。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形。几乎在任何情况下都可使用列表来代替元组。一种例外情况是将元组用作字典键，因为字典键是不允许修改的。
2 Python支持容器，容器基本上就是可包含其他对象的对象。两种主要的容器是序列（如列表和元组）和映射(如字典)。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。有一种既不是序列也不是映射的容器，集合（set）。
3 通用的序列操作：索引、切片、相加、相乘和成员资格检查。
（1）索引
① 负数索引时，Python将从右开始往左数，-1是最后一个元素的位置。
② 对于字符串字面量，可直接对其进行索引操作，无需将其先赋值给变量。
```
>>> greeting = 'Hello'
>>> greeting[-1]
'o'
>>> 'Hello'[1]
'e'
```
(2) 索引
###### 索引可以访问单个元素，切片可访问特定范围内的元素。
如果第一个索引指定的元素位于第二个索引指定的元素后边，结果为空序列。
```（）
>>> number = [1,2,3,4,5,6,7,8,9,10]
>>> number[-3:-1]
[8, 9]
>>> number[-3:0]的赋值
[]
```
步长为负数时，第一个索引必须比第二个索引大
```
>>> number[0:10:2]
[1, 3, 5, 7, 9]
>>> number[10:0:-2]
[10, 8, 6, 4, 2]
>>> number[0:10:-2]
[]
```
（3）序列相加
加法运算符来拼接字符串，不能拼接不同类型的序列。
（4）max,min
```
>>> len(number)
10
>>> max(number)
10
>>> min(number)
1
>>> max(2,3)
3
>>> min(9,3,2,5)
2
```
最后两个表达式中，调用max和min时指定的实参并不是序列，而直接将数作为实参。
4 列表
（1）列表的基本操作
①修改列表：给元素赋值（不能给不存在的元素赋值）。
如列表长度为2，不能给索引为100
②删除元素
从列表中删除元素也很容易：使用del语句来实现。
除了删除列表中的元素 ，del 语句还能用于删除其他元素。
③切片赋值
```
>>> name = list('Perl')
>>> name
['P', 'e', 'r', 'l']
>>> name[2:] = list('ar')
>>> name
['P', 'e', 'a', 'r']
```
切片复制可同时给而且多个元素赋值，通过切片赋值，可将切片替换为长度与其不同的序列。
```
>>> name = list('Perl')
>>> name[1:]=list('ython')
>>> name
['P', 'y', 't', 'h', 'o', 'n']
```
要将字符列表转换为字符串，可使用下面的表达式：
`''.join(somelist)`
```
>>> name = list('Perl')
>>> name[1:]=list('ython')
>>> name
['P', 'y', 't', 'h', 'o', 'n']
>>> ''.join(name)
'Python'
```
切片赋值可以在不需要替换原有元素的情况下插入新的元素。
```
>>> numbers=[1,5]
>>> numbers[1:1] = [2,3,4]
>>> numbers
[1, 2, 3, 4, 5]
```
“替换” 了一个空的分片，相当于插入了一个序列，可以采用相反的措施来删除切片。
```
>>> numbers
[1, 2, 3, 4, 5]
>>> numbers[1:4] = []
>>> numbers
[1, 5]
```
(2)列表方法
方法是与对象有紧密联系的函数，对象可能是列表、数字，也可能是字符串或者其
他类型的对象。通常，像下面这样调用方法。
object.method(arguments)
① append
append方法用于将一个对象附加到列表末尾。
append就地修改列表，它不会返回修改过的新列表，而是直接修改旧列表。
② clear
方法clear就地清空列表的内容。
`list.clear()` 类似于切片赋值语句lst[:] = []
③ copy
常规复制只是将另一个名称关联到列表。
```
>>> a = [1,2,3]
>>> b = a
>>> b[1]=4
>>> a
[1, 4, 3]
```
要让a与b指向不同的列表，就必须将b关联到a的副本。
```
>>> a = [1,2,3]
>>> b = a.copy()
>>> b[1] = 4
>>> a
[1, 2, 3]
```
这类似于a[:]或list(a)
④ count
ount方法统计某个元素在列表中出现的次数
⑤ extend
extend方法可以同时将多个值附加到列表的末尾。可将这些值组成的序列作为参数提供给方法extend。换言之，可使用一个列表来扩展另一个列表。
这个操作看起来很像拼接操作 ，两者最主要区别在于：extend方法修改了被扩展的序列（在这个例子中 ，就是a ） 。而常规的拼接操作则不然 ，它会返回一个全新的序列：
```
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> a.extend(b)
>>> a
[1, 2, 3, 4, 5, 6]
```
```
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> a+b
[1, 2, 3, 4, 5, 6]
>>> a
[1, 2, 3]
```
另拼接操作并非就地执行的，即他不会修改原来的列表。要获得与extend相同的效果，可将列表赋值给切片。
```
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> a[len(a):] = b
>>> a
[1, 2, 3, 4, 5, 6]
```
但可读性不高。
⑥ index 
方法index在列表中查找指定值第一次出现的索引。
```
>>> knight = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
>>> knight.index('who')
4
>>> knight[4]
'who'
```
⑦ insert
方法insert用于将一个对象插入列表。
```
>>> numbers = [1,2,3,4,5,6,7]
>>> numbers.insert(3, 'four')
>>> numbers
[1, 2, 3, 'four', 4, 5, 6, 7]
```
与extend一样，也可使用切片赋值来获得与insert一样的效果。
```
>>> numbers = [1,2,3,4,5,6,7]
>>> numbers = [1,2,3,5,6,7]
>>> numbers[3:3] = ['four']
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]
```
⑧ pop
pop方法会移除列表中的一个元素 （默认是最后一个） ，并且返回该元素的值。
```
>>> x = [1,2,3]
>>> x.pop()
3
>>> x
[1, 2]
>>> x.pop(0)
1
>>> x
[2]
```
pop可以实现一种常见的数据结构--栈，特点后进先出。
pop是唯一一个既修改列表又返回一个非None值的列表方法。
Python没有提供push，但可以用append来替代。方法pop与append效果相反，因此将刚弹出的值压入后，得到的栈与原来相同。
```
>>> x = [1,2,3]
>>> x.append(x.pop())
>>> x
[1, 2, 3]
```
如果需要实现一个先进先出(FIFO)的队列(queue),那么可以使用inset(O ....）来代替append方法.或者，也可以继续使用append方法,但必须用pop(0)来代替pop().更好的 解决方案是使用collection模块中的deque对象.
⑨ remove
方法remove用于删除第一个为指定值的元素。
```
>>> x = ['to', 'be', 'or', 'not', 'to', 'be']
>>> x.remove('be')
>>> x
['to', 'or', 'not', 'to', 'be']
```
remove是就地修改且不返回值的方法之一。不同于pop的是，它修改列表，但不返回任何值。
⑩ reverse
方法reverse按相反的顺序排列列表中的元素
```
>>> x = [1,2,3]
>>> x.reverse()
>>> x
[3, 2, 1]
```
reverse修改列表，但不返回任何值。
@11 sort
方法sort用于对列表就地排序。就地排序意味着对原来的列表进行修改，使其元素按顺序排列，而不是返回排序后的列表的副本。
```
>>> x = [2,7,4,9,5,0,6]
>>> x.sort()
>>> x
[0, 2, 4, 5, 6, 7, 9]
```
sort修改列表，但不返回任何值。
在需要排序后的列表副本并保留原始副本不变：
```
>>> x = [2,7,4,9,5,0,6]
>>> y = x.sort()
>>> print(y)
None
```
正确的方式之一是先将y关联到x的副本，再对y进行排序。
```
>>> x = [2,7,4,9,5,0,6]
>>> y = x.copy()
>>> y.sort()
>>> x
[2, 7, 4, 9, 5, 0, 6]
>>> y
[0, 2, 4, 5, 6, 7, 9]
```
为获取排序后的列表的副本，另一种方式是使用函数sorted。
```
>>> x = [2,7,4,9,5,0,6]
>>> y = sorted(x)
>>> x
[2, 7, 4, 9, 5, 0, 6]
>>> y
[0, 2, 4, 5, 6, 7, 9]
```
实际上，这个函数可用于任何序列，但总返回一个列表。
```
>>> sorted('Python')
['P', 'h', 'n', 'o', 't', 'y']
>>> sorted('python')
['h', 'n', 'o', 'p', 't', 'y']
```
如果要将元素按相反的顺序排列，可先使用sort(或sorted)，再调用方法reverse，也可使用参数reverse。
@12 高级排序
方法sort可接受两个可选参数：key和reverse。这两个关键字通常是按照名称指定的，成为关键字参数。
参数key类似于参数cmp：你将其设置为一个用于排序的函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这个键对元素进行排序。
```
>>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate']
>>> x.sort(key=len)
>>> x
['add', 'acme', 'aerate', 'abalone', 'aardvark']
```
另一个关键字参数reverse是简单的布尔值 （True或者是False。第5章会讲述更详细的内容）
用来指明列表是否要进行反向排序。
```
>>> x = [2,7,4,9,5,0,6]
>>> x.sort(reverse=True)
>>> x
[9, 7, 6, 5, 4, 2, 0]
```
5 元组：不可修改的序列
（1）元组也是序列，唯一差别在于元组是不能修改的。
空元组可以用没有包含内容的两个圆括号来表示
那么如何实现包括一个值的元组呢。实现方法有些奇特一一必须加个逗号，即使只有一个值：
```
>>> 3 *(40+2)
126
>>> 3 *(40+2,)
(42, 42, 42)
```
(2)tuple函数的功能与1ist函数基本上是一样的：以一个序列作为参数井把它转换为元组.如果参数就是元组，那么该参数就会被原样返回：
```
>>> tuple([1,2,3])
(1, 2, 3)
>>> tuple('abc')
('a', 'b', 'c')
>>> tuple((1,2,3))
(1, 2, 3)
```
(3)①元组可以在映射(和集合的成员)中当作键使用一一而列表则不行.
② 有些内置函数和方法返回元组，这意味着必须跟它们打交道。只要不尝试修改元组，与元组打交道通常意味着像处理列表一样处理它们。
一般来说 ，列表可能更能满足对序列的所有需求。